"""
Malware Detection and Feature Extraction Module

This module provides machine learning-based malware detection using the EMBER
(Endgame Malware Bytes Research) feature extractor. It handles feature extraction,
model inference, and alert tracking for detected malware.
"""

import joblib
import pandas as pd
import numpy as np
from pathlib import Path
import logging
import lief
from app.core.config import get_settings
from app.core.ember_extractor import PEFeatureExtractor

# ============================
# Configuration and Logging
# ============================

logger = logging.getLogger(__name__)

settings = get_settings()
MODEL_PATH = Path(settings.MODEL_PATH)

# ============================
# Model Loading
# ============================

try:
    model = joblib.load(MODEL_PATH)
    logger.info(f"ML model loaded from {MODEL_PATH}")
except Exception as e:
    raise RuntimeError(f"Failed to load ML model: {e}")

# ============================
# Feature Extractor Initialization
# ============================

# Initialize EMBER feature extractor for PE file feature generation
extractor = PEFeatureExtractor(feature_version=2)
EXPECTED_FEATURES = model.n_features_in_
logger.info(f"EMBER feature extractor initialized. Expecting {EXPECTED_FEATURES} features.")

# ============================
# In-Memory Alerts Store
# ============================
# NOTE: This is stored in-memory. In production, consider using a database.

alerts = []


def get_alerts():
    """
    Get recent alerts.
    
    Returns:
        list: Last 100 alerts that have been recorded
    """
    return alerts[-100:]


def add_alert(filename: str, prob: float, status: str):
    """
    Record a new malware alert.
    
    Args:
        filename: Name of the file that triggered the alert
        prob: Malware probability score (0.0 to 1.0)
        status: Detection verdict ('malicious', 'benign', 'suspicious', etc.)
    """
    alert = {
        "filename": filename,
        "prob": prob,
        "status": status
    }
    alerts.append(alert)
    logger.info(f"New alert added: {alert}")

# ============================
# Feature Extraction Functions
# ============================

def extract_features(file_path: str) -> np.ndarray:
    """
    Extract EMBER features from a PE file.
    
    Reads a binary file and extracts machine learning features using the EMBER
    feature extractor. If extraction fails, returns a zero-padded vector.
    
    Args:
        file_path: Path to the PE binary file to extract features from
        
    Returns:
        np.ndarray: Feature vector of size EXPECTED_FEATURES, padded with zeros if needed
    """
    try:
        with open(file_path, "rb") as f:
            bytez = f.read()
    except Exception as e:
        logger.error(f"Failed to read file {file_path}: {e}")
        return np.zeros(EXPECTED_FEATURES, dtype=np.float32)

    # LIEF library exception types to catch
    lief_errors = (
        lief.bad_format,
        lief.bad_file,
        lief.pe_error,
        lief.parser_error,
        lief.read_out_of_bound,
        RuntimeError,
    )

    try:
        features = extractor.feature_vector(bytez)
        
        # Pad or trim features to expected size
        if len(features) != EXPECTED_FEATURES:
            padded = np.zeros(EXPECTED_FEATURES, dtype=np.float32)
            length = min(len(features), EXPECTED_FEATURES)
            padded[:length] = features[:length]
            features = padded
            
        return features

    except lief_errors as e:
        logger.warning(f"LIEF error extracting features from {file_path}: {e}")
        return np.zeros(EXPECTED_FEATURES, dtype=np.float32)

    except Exception as e:
        logger.error(f"Unexpected feature extraction error: {e}")
        return np.zeros(EXPECTED_FEATURES, dtype=np.float32)

# ============================
# Malware Prediction Function
# ============================

def predict_malware(input_data, filename: str = None) -> float:
    """
    Predict malware probability for a file or feature vector.
    
    Accepts either a file path (extracts features automatically) or a pre-computed
    feature vector. Returns a probability between 0.0 and 1.0.
    
    Args:
        input_data: Either:
                   - str or Path: path to the PE file to scan
                   - list or np.ndarray: pre-computed feature vector
        filename: Optional filename for alert recording. If provided and
                 detection occurs, an alert will be recorded.
                 
    Returns:
        float: Malware probability score (0.0 = benign, 1.0 = malicious)
               Returns 0.0 if prediction fails
    """
    try:
        # Extract features if input is a file path
        if isinstance(input_data, (str, Path)):
            features = extract_features(str(input_data))
        elif isinstance(input_data, (list, np.ndarray)):
            # Convert list/array to numpy array and pad if necessary
            features = np.array(input_data)
            if len(features) != EXPECTED_FEATURES:
                padded = np.zeros(EXPECTED_FEATURES, dtype=np.float32)
                length = min(len(features), EXPECTED_FEATURES)
                padded[:length] = features[:length]
                features = padded
        else:
            raise ValueError(f"Unsupported input type: {type(input_data)}")

        # Prepare dataframe for model prediction
        X = pd.DataFrame(
            features.reshape(1, -1),
            columns=[f"f{i}" for i in range(EXPECTED_FEATURES)]
        )

        # Get probability from model
        if hasattr(model, "predict_proba"):
            prob = float(model.predict_proba(X)[0][1])
        else:
            prob = float(model.predict(X)[0])

        # Determine detection status
        status = "malicious" if prob >= 0.5 else "benign"

        # Record alert if filename provided
        if filename:
            add_alert(filename, prob, status)

        return prob

    except Exception as e:
        logger.error(f"Prediction failed: {e}")
        return 0.0
