# app/core/malware.py
import joblib
import pandas as pd
import numpy as np
from pathlib import Path
import logging
import lief
from app.core.config import get_settings
from app.core.ember_extractor import PEFeatureExtractor

# ----------------------------
# Logging
# ----------------------------
logger = logging.getLogger(__name__)

# ----------------------------
# Load settings & model
# ----------------------------
settings = get_settings()
MODEL_PATH = Path(settings.MODEL_PATH)

try:
    model = joblib.load(MODEL_PATH)
    logger.info(f"ML model loaded from {MODEL_PATH}")
except Exception as e:
    raise RuntimeError(f"Failed to load ML model: {e}")

# ----------------------------
# Initialize EMBER extractor
# ----------------------------
extractor = PEFeatureExtractor(feature_version=2)
EXPECTED_FEATURES = model.n_features_in_
logger.info(f"EMBER feature extractor initialized. Expecting {EXPECTED_FEATURES} features.")

# ----------------------------
# In-memory alerts store (can later be replaced with DB)
# ----------------------------
alerts = []

def get_alerts():
    """Return all recent alerts"""
    return alerts[-100:]  # keep last 100 alerts

def add_alert(filename: str, prob: float, status: str):
    """Add a new alert"""
    alert = {
        "filename": filename,
        "prob": prob,
        "status": status
    }
    alerts.append(alert)
    logger.info(f"New alert added: {alert}")

# ----------------------------
# Feature extraction
# ----------------------------
def extract_features(file_path: str) -> np.ndarray:
    try:
        with open(file_path, "rb") as f:
            bytez = f.read()
    except Exception as e:
        logger.error(f"Failed to read file {file_path}: {e}")
        return np.zeros(EXPECTED_FEATURES, dtype=np.float32)

    lief_errors = (
        lief.bad_format,
        lief.bad_file,
        lief.pe_error,
        lief.parser_error,
        lief.read_out_of_bound,
        RuntimeError,
    )

    try:
        features = extractor.feature_vector(bytez)
        if len(features) != EXPECTED_FEATURES:
            padded = np.zeros(EXPECTED_FEATURES, dtype=np.float32)
            length = min(len(features), EXPECTED_FEATURES)
            padded[:length] = features[:length]
            features = padded
        return features

    except lief_errors as e:
        logger.warning(f"LIEF error extracting features from {file_path}: {e}")
        return np.zeros(EXPECTED_FEATURES, dtype=np.float32)

    except Exception as e:
        logger.error(f"Unexpected feature extraction error: {e}")
        return np.zeros(EXPECTED_FEATURES, dtype=np.float32)

# ----------------------------
# Prediction with alert
# ----------------------------
def predict_malware(input_data, filename: str = None) -> float:
    """
    Predict malware probability and optionally create an alert if malicious.
    
    Args:
        input_data: str (file path) OR list/np.ndarray of features
        filename: Optional, required if you want to record an alert
    Returns:
        float: malware probability
    """
    try:
        # Extract features if input is file
        if isinstance(input_data, (str, Path)):
            features = extract_features(str(input_data))
        elif isinstance(input_data, (list, np.ndarray)):
            features = np.array(input_data)
            if len(features) != EXPECTED_FEATURES:
                padded = np.zeros(EXPECTED_FEATURES, dtype=np.float32)
                length = min(len(features), EXPECTED_FEATURES)
                padded[:length] = features[:length]
                features = padded
        else:
            raise ValueError(f"Unsupported input type: {type(input_data)}")

        # Prepare dataframe for model
        X = pd.DataFrame(features.reshape(1, -1),
                        columns=[f"f{i}" for i in range(EXPECTED_FEATURES)])

        if hasattr(model, "predict_proba"):
            prob = float(model.predict_proba(X)[0][1])
        else:
            prob = float(model.predict(X)[0])

        # Determine status
        status = "malicious" if prob >= 0.5 else "benign"

        # Add alert if filename is provided
        if filename:
            add_alert(filename, prob, status)

        return prob

    except Exception as e:
        logger.error(f"Prediction failed: {e}")
        return 0.0
